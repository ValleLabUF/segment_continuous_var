---
title: "Exploration of Coarse-Scale Snail Kite Behavior"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    social: menu
    source_code: https://github.com/ValleLabUF/segment_continuous_var
    theme: journal
---
<style>
.navbar-inverse {
  background-color: blue;
  border-color: white;
}

.navbar-inverse .navbar-brand:hover,
.navbar-inverse .navbar-brand:focus {
  color: white;
  background-color: #FF7F00;
}

.navbar-inverse .navbar-nav > li > a:hover,
.navbar-inverse .navbar-nav > li > a:focus {
  color: white;
  background-color: #FF7F00;
}

.navbar-inverse .navbar-nav > .active > a,
.navbar-inverse .navbar-nav > .active > a:hover,
.navbar-inverse .navbar-nav > .active > a:focus {
  color: white;
  background-color: #FF7F00;
}
</style>



```{r setup, include=FALSE}
library(flexdashboard)
library(shiny)
library(dplyr)
# library(ggplot2)
library(purrr)
library(sf)
library(rgdal)
# library(raster)
library(viridis)
library(rgeos)
# library(tidyr)
library(leaflet)
# library(highcharter)
# library(bayesmove)
library(lubridate)
# library(plotly)
library(dygraphs)
library(xts)
# library(purrrlyr)
library(shinyWidgets)

#####################
#### Import data ####
#####################

# source('helper functions.R')

dat<- read.csv("Snail Kite Gridded Data_TOHO_R2n.csv", header = T, sep = ",")

dat$id<- as.character(dat$id)
dat$date<- as_datetime(dat$date)


#make reactive NSD data
dat.filt<- reactive({
  
d<- dat[dat$id == input$animal_id, ]
return(d)
})



```





Explore NSD
======================================================================

Sidebar {.sidebar}
-----------------------------------------------------------------------
<style>
.section.sidebar {
  top: 61px;
  background-color: rgba(255, 127, 0, 0.25);
}
</style>

```{r}
# Define inputs
selectInput('animal_id', label = 'Select an ID', choices = unique(dat$id), selected = "SNIK 12")

```

Use the __Explore NSD__ tab to explore temporal patterns in net squared displacement (NSD). Click and drag on the lineplot to highlight the corresponding time range on the map below. Grey shaded regions indicate peak breeding season (March 1^st^ to June 30^th^).

Click the __View all tracks__ tab to view tracks for all individuals. This provides a quick overview of all track segments separately and allows for filtering tracks by time.  

Application author: [Josh Cullen](https://joshcullen.github.io/), [University of Florida](http://www.ufl.edu)





Row
-----------------------------------------------------------------------

### Net Squared Displacement Time-Series

```{r}

# Plot the NSD line trace with Plotly
# output$lineplot <- renderPlotly({
#   
#   key<- dat.filt()$id # This will uniquely identify tracts for Plotly
#   
#   p1<- ggplot(dat.filt()) + 
#     geom_line(aes(date, NSD, key = key)) + 
#     theme_bw() + 
#     theme(panel.grid = element_blank(),
#           axis.title = element_text(size = 16),
#           axis.text = element_text(size = 12)) + 
#     labs(x = 'Date', expression("NSD ", (m^2)))
#     
#   g<- ggplotly(p1, source = 'source') %>% 
#     layout(dragmode = 'zoom', 
#            # yaxis = list(title = 'Diversity score'), 
#            margin = list(l = 100), 
#            font = list(family = 'Open Sans', size = 16))
#   
#   # Need to manually set the hoverinfo to avoid the key appearing in it
#   build<- plotly_build(g)
#   
#   build$data[[1]]$text <- paste0('NSD = ', round(dat.filt()$NSD, 2), '<br>', 
#                                'Track Segment ', dat.filt()$tseg) 
#   build
#     
# })  
# 
# plotlyOutput('lineplot', width = "80%")







#make reactive brkpt data
# brkpts.filt<- reactive({
#   
#   b<- brkpts[brkpts$id == unique(dat.filt()$id), ] %>% 
#     purrr::discard(is.na)
#   b<- b[,-1]
#   b2<- dat.filt()$date[as.numeric(b)]
#   
#   return(b2)
#   
# })

output$lineplot<- renderDygraph({
  
dygraph(xts(x = dat.filt()$NSD / 1e06, order.by = dat.filt()$date)) %>%
    dySeries(label = "NSD", strokeWidth = 1.5) %>% 
    dyAxis("y", label = "NSD (km<sup>2</sup>)", axisLabelFontSize = 16, axisLabelWidth = 75) %>%
    dyRangeSelector(dateWindow = NULL) %>% 
    dyOptions(axisLineWidth = 1.5, drawGrid = FALSE, colors = "black") %>% 
    dyLegend(width = 270) %>% 
    dyShading(from = "2018-03-01", to = "2018-06-30") %>%
    dyShading(from = "2019-03-01", to = "2019-06-30") %>% 
    dyUnzoom() %>% 
    dyCrosshair(direction = "vertical")
    
})


reacted.data<- reactive({
  req(input$lineplot_date_window)  #to prevent warning from 'if' expression
  
  start=strptime(input$lineplot_date_window[[1]], format = "%Y-%m-%dT%H:%M:%S", tz = "UTC")
  end=strptime(input$lineplot_date_window[[2]], format = "%Y-%m-%dT%H:%M:%S", tz = "UTC")

    if (start == min(dat.filt()$date) & end == max(dat.filt()$date)){
      dat.filt()
    } else {
      subset = dplyr::filter(dat.filt(), date >= start & date <= end)
      return(subset)
    }
  })


dygraphOutput("lineplot")
```



### Track Map

```{r}
# Draw the map without selected tracts
output$map <- renderLeaflet({

    bounds<- reactive({
      dat.sf<- st_as_sf(dat.filt(), coords = c("x","y"), crs = 32617) %>%
        st_transform(4326)
      extent<- as.numeric(st_bbox(dat.sf))
      
      return(extent)
    })
  
    
    leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
    addProviderTiles(providers$Esri.OceanBasemap, group = "Ocean Basemap",
                        options = tileOptions(continuous_world = F)) %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery",
                        options = tileOptions(continuous_world = F)) %>%
    addProviderTiles(providers$CartoDB.DarkMatterNoLabels, group = "Dark Map",
                        options = tileOptions(continuous_world = F)) %>%
    fitBounds(bounds()[1], bounds()[2], bounds()[3], bounds()[4]) %>% 
    # addPolylines(data = dat.filt(),
    #              lng = unlist(map(dat.filt()$geometry,1)),
    #              lat = unlist(map(dat.filt()$geometry,2)),
    #              weight = 2,
    #              layerId = ~unique(id),
    #              color = "grey") %>%
    addMeasure(position = "topleft",
               primaryLengthUnit = "kilometers",
               primaryAreaUnit = "hectares",
               activeColor = "#3D535D",
               completedColor = "#7D4479") %>%
    addMiniMap(tiles = providers$Esri.OceanBasemap,
               toggleDisplay = TRUE,
               position = "bottomleft") %>% 
      addScaleBar() %>% 
      addLayersControl(baseGroups = c("World Imagery", "Ocean Basemap", "Dark Map"), 
                   options = layersControlOptions(collapsed = TRUE))
  })

####---------------------------------------------------


# UPDATED MAP
observe({
  req(reacted.data()) # Do this if reacted.data() is not null
#   
#   #set palette
#   # pal1<- colorNumeric(palette = "Spectral", domain = dat.filt()$tseg)
#   # pal1.rev<- colorNumeric(palette = "viridis", domain = dat.filt()$tseg, reverse = T)
#   
#   
  df<- reactive({
    df<- reacted.data()

    dat.sf<- st_as_sf(df, coords = c("x","y"), crs = 32617) %>%
      st_transform(4326) %>%
      # summarize(do_union = FALSE) %>%
      st_cast("LINESTRING") #%>% 
      # mutate(x = unlist(map(.$geometry,1)),
      #        y = unlist(map(.$geometry,2))) %>%
      # st_drop_geometry()

    dat.sf

  })
  
  
  df.start.pt<- reactive({
    df<- reacted.data()

    dat.sf<- sf::st_as_sf(df, coords = c("x","y"), crs = 32617) %>%
       sf::st_transform(4326) %>%
       # summarize(do_union = FALSE) %>%
       # st_cast("POINT") %>% 
       dplyr::slice(1)

    dat.sf

  })
  
  df.end.pt<- reactive({
    df<- reacted.data()

    dat.sf<- sf::st_as_sf(df, coords = c("x","y"), crs = 32617) %>%
       sf::st_transform(4326) %>%
       # summarize(do_union = FALSE) %>%
       # st_cast("POINT") %>% 
       dplyr::slice(nrow(df))

    dat.sf

  })
  
   
   
   
  # Clear old selection on map, and add new selection
  leaflet::leafletProxy('map', data = df()) %>%
  leaflet::clearControls() %>%
  leaflet::clearShapes() %>%
  leaflet::clearMarkers() %>% 
  leaflet::fitBounds(as.numeric(sf::st_bbox(df())[1]),
            as.numeric(sf::st_bbox(df())[2]),
            as.numeric(sf::st_bbox(df())[3]),
            as.numeric(sf::st_bbox(df())[4])) %>%
  leaflet::addPolylines(lng = as.numeric(sf::st_coordinates(df())[,1]),
               lat = as.numeric(sf::st_coordinates(df())[,2]),
               weight = 2,
               color = "darkturquoise",
               opacity = 0.8) %>% 
  leaflet::addCircleMarkers(data = df.start.pt(),
                   # lng = as.numeric(sf::st_coordinates(df.start.pt())[,1]),
                   # lat = as.numeric(sf::st_coordinates(df.start.pt())[,2]),
                   fillColor = "#5EF230",
                   stroke = FALSE,
                   fillOpacity = 0.8) %>%
  leaflet::addCircleMarkers(data = df.end.pt(),
                   # lng = as.numeric(sf::st_coordinates(df.end.pt())[,1]),
                   # lat = as.numeric(sf::st_coordinates(df.end.pt())[,2]),
                   fillColor = "red",
                   stroke = FALSE,
                   fillOpacity = 0.8)
  
})


leafletOutput('map')


```



View all tracks
======================================================================

Sidebar {.sidebar}
-----------------------------------------------------------------------
<style>
.section.sidebar {
  top: 61px;
  background-color: rgba(255, 127, 0, 0.25);
}
</style>

<br />
```{r}
pickerInput(
   inputId = "select_ids",
   label = "Select/deselect by ID", 
   choices = unique(dat$id),
   selected = unique(dat$id),
   options = list(
      `actions-box` = TRUE), 
    multiple = TRUE
)

```
<br />


Use the __Explore NSD__ tab to explore temporal patterns in net squared displacement (NSD). Click and drag on the lineplot to highlight the corresponding time range on the map below. Grey shaded regions indicate peak breeding season (March 1^st^ to June 30^th^).

Click the __View all tracks__ tab to view tracks for all individuals. This provides a quick overview of all track segments separately and allows for filtering tracks by time.  

Application author: [Josh Cullen](https://joshcullen.github.io/), [University of Florida](http://www.ufl.edu)


Row {data-height=150, align="center"}
-----------------------------------------------------------------------

### Dates

<style>
.irs-bar {width: 100%; height: 10px;}
.irs-line {border: 1px solid black; height: 10px; border-radius: 0px;}
      .irs-max {font-family: 'arial'; color: black;}
      .irs-min {font-family: 'arial'; color: black;}
      .irs-single {color:black; background:#6666ff;}
      .irs-grid-text {font-size: 12pt; color: black}
      
</style>

```{r}
# Define inputs

div(style="width: 1000px; ", sliderInput("range", NULL,
                  min = min(dat$date), max = max(dat$date),
                  value = range(dat$date), width = '100%', step = 90))
```


Row {data-height=850}
-----------------------------------------------------------------------

### Map of All Tracks

```{r}

#make reactive data based on slider input
dat.filt2<- reactive({

d.list<- split(dat, dat$id)  #split data into list by ID
d2<- bind_rows(d.list[input$select_ids])  #only keep selected IDs
d2<- d2[d2$date >= input$range[1] & d2$date <= input$range[2], ]  #only keep w/in date range
return(d2)
})


# Store map as reactive expression for render and download
tracks.map<- reactive({
  
  #format data where each ID is a linestring
    dat.sf<- st_as_sf(dat.filt2(), coords = c("x","y"), crs = 32617) %>%
             st_transform(4326) %>% 
             group_by(id) %>% 
             summarize(do_union=F) %>% 
             st_cast("LINESTRING")
    
    #set palette
    pal1<- colorFactor(palette = "viridis", domain = dat.sf$id)
    
    labs<- sprintf("<strong>ID %s</strong><br/>", dat.sf$id) %>%
       lapply(htmltools::HTML)

  
    leaflet(options = leafletOptions(preferCanvas = TRUE)) %>%
    addProviderTiles(providers$Esri.OceanBasemap, group = "Ocean Basemap",
                        options = tileOptions(continuous_world = F)) %>%
    addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery",
                        options = tileOptions(continuous_world = F)) %>%
    addProviderTiles(providers$CartoDB.DarkMatterNoLabels, group = "Dark Map",
                        options = tileOptions(continuous_world = F)) %>%
    addPolylines(data = dat.sf,
                 weight = 2,
                 # layerId = ~unique(id),
                 color = ~pal1(id),
                 label = labs) %>%
    leaflet::addLegend("bottomright",
                 pal = pal1,
                 values = dat.sf$id,
                 title = "ID",
                 opacity = 1) %>%
    addMeasure(position = "topleft",
               primaryLengthUnit = "kilometers",
               primaryAreaUnit = "hectares",
               activeColor = "#3D535D",
               completedColor = "#7D4479") %>%
    addMiniMap(tiles = providers$Esri.OceanBasemap,
               toggleDisplay = TRUE,
               position = "bottomleft") %>% 
      addScaleBar() %>% 
      addLayersControl(baseGroups = c("Ocean Basemap", "World Imagery", "Dark Map"), 
                   options = layersControlOptions(collapsed = TRUE), position = "topleft")
})

# Draw the map of all tracks
output$map_all <- renderLeaflet({

  tracks.map()
    
  })



leafletOutput('map_all')
```
